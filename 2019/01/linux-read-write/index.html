<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:url" content="https://blog.jaycetyle.com/2019/01/linux-read-write/"><meta property="og:site_name" content="Jayce 的共享記憶體"><meta property="og:title" content="Linux 系統程式設計 - read()、write() 與 page cache"><meta property="og:description" content="這篇延續 Linux 系統程式設計 - fd 及 open()、close() 系統呼叫一文，主要筆記 read()、write() 系統呼叫及 page cache 相關的部分"><meta property="og:locale" content="zh_tw"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-01-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-02T00:00:00+00:00"><meta property="article:tag" content="C/C++"><meta property="article:tag" content="Linux Kernel"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 系統程式設計 - read()、write() 與 page cache"><meta name=twitter:description content="這篇延續 Linux 系統程式設計 - fd 及 open()、close() 系統呼叫一文，主要筆記 read()、write() 系統呼叫及 page cache 相關的部分"><title>Linux 系統程式設計 - read()、write() 與 page cache | Jayce 的共享記憶體
</title><link rel="shortcut icon" href=/images/favicon.ico><link rel="shortcut icon" href=/images/favicon.png><link rel=apple-touch-icon-precomposed href=/images/apple-touch-icon-precomposed.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=/images/apple-touch-icon-72x72-precomposed.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=/images/apple-touch-icon-114x114-precomposed.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=/images/apple-touch-icon-144x144-precomposed.png><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400&display=swap" rel=stylesheet media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400&display=swap" rel=stylesheet></noscript><link rel=preload href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css as=style><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><script defer src=https://kit.fontawesome.com/718a56e2d4.js crossorigin=anonymous></script><script>window.themeUrls={light:"/css/light.min.0d91bc92b83a6a8aac989d53ce618ea99f98702fd931a07d8219dd7c3ae030eb.css",dark:"/css/dark.min.af88a93f842d8c67b00708066264a518670df2f2fc97f2246b1282d6c721961c.css"}</script><link rel=stylesheet href=https://blog.jaycetyle.com/css/styles.min.6a7e3e1c24ad4b4b16f344cfc54f4b5a4e92f35366ada3879f0176264c5f99b9.css integrity="sha256-an4+HCStS0sW80TPxU9LWk6S81NmraOHnwF2Jkxfmbk="><link id=theme-style rel=stylesheet href><script src=/js/theme.min.c60c34ed95ff0b346a1dae4dd465c4f433335a8d9eb0f6966393bfd86b71f203.js integrity="sha256-xgw07ZX/CzRqHa5N1GXE9DMzWo2esPaWY5O/2Gtx8gM="></script><link rel=me type=text/html href=https://www.linkedin.com/in/chieh-lin-569430a9/><link rel="shortcut icon" href=/images/favicon.ico><link rel="shortcut icon" href=/images/favicon.png><link rel=apple-touch-icon-precomposed href=/images/apple-touch-icon-precomposed.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=/images/apple-touch-icon-72x72-precomposed.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=/images/apple-touch-icon-114x114-precomposed.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=/images/apple-touch-icon-144x144-precomposed.png><link rel=alternate type=application/rss+xml href=https://blog.jaycetyle.com/index.xml><meta charset=utf-8><meta name=author content><meta name=copyright content><meta name=description content="這篇延續 Linux 系統程式設計 - fd 及 open()、close() 系統呼叫一文，主要筆記 read()、write() 系統呼叫及 page cache 相關的部分"><style type=text/css>.feature-image{background-image:linear-gradient( rgba(0,0,0,.15),rgba(0,0,0,.15) ),url(https://blog.jaycetyle.com/images/banner.jpg);height:400px;background-repeat:no-repeat;background-size:cover;background-position:50%}.feature-image-text{margin-top:20px}@media(max-width:1024px){.feature-image{height:300px}}@media(max-width:768px){.feature-image{height:250px}}@media(max-width:520px){.feature-image{display:none}}</style></head><body><nav class="navbar fixed-top navbar-expand-md navbar-primary bg-primary py-1 top-nav"><div class=container><a href=https://blog.jaycetyle.com/><img alt class=logo src=https://blog.jaycetyle.com//images/logo.png></a>
<a class="navbar-brand pr-4 d-none d-sm-block" href=https://blog.jaycetyle.com/>Jayce's Shared Memory</a>
<button class="navbar-toggler collapsed" type=button data-toggle=collapse data-target=#navbarCollapse aria-controls=navbarCollapse aria-expanded=false aria-label="Toggle navigation"><svg width="24" height="24" fill="#000" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M3 6h18M3 12h18M3 18h18" stroke="#000" stroke-width="2" stroke-linecap="round"/></svg></button><div class="navbar-collapse collapse" id=navbarCollapse><ul class="navbar-nav mr-auto"><li class=nav-item><a class="nav-link active" href=https://blog.jaycetyle.com/>Home</a></li><li class=nav-item><a class="nav-link active" href=https://blog.jaycetyle.com/archive/>Archive</a></li><li class=nav-item><a class="nav-link active" href=https://github.com/jaycetyle>Github</a></li><li class=nav-item><a class="nav-link active" href=https://blog.jaycetyle.com/about/>About</a></li><li class=nav-item><button id=theme-toggle onclick=toggleTheme() class=nav-link style="background:0 0;border:none;color:inherit;cursor:pointer">
🌙</button></li></ul></div></div></nav><header class=feature-image><div class="feature-image-text white-shadow-text"><h1 class=font-weight:bold>Linux 系統程式設計 - read()、write() 與 page cache</h1></div></header><div class="container main my-4"><div class="post p-3 p-sm-5"><h3 class=post-title>Linux 系統程式設計 - read()、write() 與 page cache</h3><div class="mt-2 mb-3"><small><strong>By Lin Chieh (Jayce)</strong>
| <i class="far fa-calendar-alt"></i>&nbsp;Jan 1, 2019&nbsp;
| <i class="fa fa-tags" title=Tags aria-hidden=true></i> <a href=/tags/c/c++/>C/C++</a>, <a href=/tags/linux-kernel/>Linux Kernel</a></small></div><div class="mt-4 mb-4 main-content"><p>　　這篇延續 <a href=https://blog.jaycetyle.com/2018/12/linux-fd-open-close/>Linux 系統程式設計 - fd 及 open()、close() 系統呼叫</a>，筆記 read()、write() 系統呼叫及 page cache 相關的部分。內容主要參考 <a href=https://www.tenlong.com.tw/products/9789862769812>Robert Love 的 Linux System Programming</a> 一書。</p><h2 id=read-系統呼叫>read() 系統呼叫</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#e5e5e5>#include</span> <span style=color:#e5e5e5>&lt;unistd.h&gt;</span><span style=color:#e5e5e5>
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5></span>
</span></span><span style=display:flex><span><span style=color:violet>ssize_t</span> <span style=color:#ff0>read</span>(<span style=color:violet>int</span> fd, <span style=color:violet>void</span> *buf, <span style=color:violet>size_t</span> len);</span></span></code></pre></div><p>　　read() 系統呼叫會從 fd 所參照檔案的當前位置讀取 len 個位元組到 buf，執行成功時會回傳寫進 buf 的位元組數，同時檔案位置也會前進所讀取的位元組數，執行失敗時會回傳 -1 並設定 errno。</p><p>　　雖然 read() 是一個簡單的系統呼叫，但要恰當地進行錯誤處理其實也是相當複雜的，根據不同的狀況，大致上有以下幾種回傳結果:</p><ul><li>回傳值等於 len: 這是預期的正確結果</li><li>回傳值等於 0: 表示到了檔案末端 (EOF)，沒有資料可以讀取</li><li>回傳值小於 0: 一般代表發生錯誤，有以下幾種可能:<ul><li>errno = EINTR。表示在讀取過程中收到的信號，可以嘗試再讀取一次</li><li>errno = EAGAIN。在 O_NONBLOCK 模式下才會有的情況，表示還沒有資料可以讀取，可以等候一段時間後再嘗試一次</li><li>其他的 errno。可能是嚴重的錯誤，重試不一定有用</li></ul></li><li>回傳值大於 0 但小於 len: 可能是以下三種情況之一，再嘗試讀取一次通常就可以找到真正原因:<ul><li>讀取過程中收到信號中斷</li><li>讀取過程中發生錯誤</li><li>可讀取的大小不足 len 或以到達 EOF</li></ul></li></ul><p>　　EINTR 是比較常被忽視的，他算是高機會可回復的錯誤，如果程式會對信號進行處理的話，應該是需要被考慮處理的錯誤。</p><p>　</p><h2 id=write-系統呼叫>write() 系統呼叫</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#e5e5e5>#include</span> <span style=color:#e5e5e5>&lt;unistd.h&gt;</span><span style=color:#e5e5e5>
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5></span>
</span></span><span style=display:flex><span><span style=color:violet>ssize_t</span> <span style=color:#ff0>write</span>(<span style=color:violet>int</span> fd, <span style=color:red>const</span> <span style=color:violet>void</span> *buf, <span style=color:violet>size_t</span> count);</span></span></code></pre></div><p>　　write() 系統呼叫會從 buf 中把 count 位元組的資料寫入 fd 所參照檔案的當前位置，執行成功時會回傳寫進入檔案的位元組數，檔案位置也會前進寫入的位元組數，執行失敗時會回傳 -1 並設定 errno。write() 不像 read() 會遇到 EOF，比較不容易發生回傳值不等於 count，但如果 write 的對象是 socket 的話，就仍然要處理只有部分寫入的情況 (回傳小於 count 但大於等於 0)。</p><p>　</p><h2 id=lseek-系統呼叫>lseek() 系統呼叫</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#e5e5e5>#include</span> <span style=color:#e5e5e5>&lt;sys/types.h&gt;</span><span style=color:#e5e5e5>
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5>#include</span> <span style=color:#e5e5e5>&lt;unistd.h&gt;</span><span style=color:#e5e5e5>
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5></span>
</span></span><span style=display:flex><span><span style=color:violet>off_t</span> <span style=color:#ff0>lseek</span>(<span style=color:violet>int</span> fd, <span style=color:violet>off_t</span> pos, <span style=color:violet>int</span> origin);</span></span></code></pre></div><p>　　lseek() 系統呼叫用來設定檔案的當前位置，本身不會產生任何 IO，成功時會回傳檔案的當前位置，失敗時回傳 -1 並設定 errn。lseek() 的 pos 可以是正、負或是零，實際的行為取決於 origin，可以是以下幾種的其中一個:</p><ul><li>SEEK_CUR: 位置設定為當前位置加上 pos<ul><li>pos 是零時可以用來查詢目前檔案位置</li></ul></li><li>SEEK_END: 位置設定為當前的長度再加上 pos，也就是從結尾開始算的意思<ul><li>pos 是零時可以把當前位置設為檔案結尾</li></ul></li><li>SEEK_SET: 位置設定為 pos，也就是從開頭開始算的意思<ul><li>pos 是零時可以把當前位置設為檔案開頭</li></ul></li></ul><p>　　lseek() 也可以把檔案當前位置設定到檔案結尾以後。此時如果進行讀取的話，會回傳 EOF，若進行寫入的話，中間被跳過的部分會以 hole 的形式填補成 0 而變成 sparse file。</p><p>　　另外 Linux 還有提供了結合 read()、write() 及 lssek() 的變體，他們會從 pos 的位置做讀取或寫入，且完成後<strong>不會</strong>更動檔案的目前位置，且他也可以避免多執行緒情境下先做 lseek() 再做 read()、write() 可能的 race 情況。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#e5e5e5>#define _XOPEN_SOURCE 500
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5>#include</span> <span style=color:#e5e5e5>&lt;unistd.h&gt;</span><span style=color:#e5e5e5>
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5></span>
</span></span><span style=display:flex><span><span style=color:violet>ssize_t</span> <span style=color:#ff0>pread</span>(<span style=color:violet>int</span> fd, <span style=color:violet>void</span> *buf, <span style=color:violet>size_t</span> count);
</span></span><span style=display:flex><span><span style=color:violet>ssize_t</span> <span style=color:#ff0>pwrite</span>(<span style=color:violet>int</span> fd, <span style=color:red>const</span> <span style=color:violet>void</span> *buf, <span style=color:violet>size_t</span> count);</span></span></code></pre></div><p>　</p><h2 id=淺談-page-cache>淺談 Page Cache</h2><p>　　Page cache 這東西我一直都是知道但理解很淺，這裡主要整理讀到的相關資料，之後會再找個時間去深入研究核心的程式碼。</p><p>　　Page cache 用來暫存從磁碟上讀起來的檔案系統資料，由於一般硬碟存取速度遠低於記憶體存取速度，因此將資料暫存在記憶體是非常值得的。在尋找檔案系統資料時，核心實際上也是先從 Page cache 尋找，如果不在 cache 中，才會從磁碟中將資料讀取上來。寫入的情況也是，當呼叫 write() 系統呼叫時，核心把資料複製到 page cache 中以後就已經返回了，而這些蒐集到 cache 中的資料會被標記成 dirty，在之後由背景的 flusher 核心執行緒將其寫回 (writeback) 至磁碟中。</p><p>　　和 page cache 相關的參數常見的有以下幾個，位於 /proc/sys/vm/ 目錄底下，這些參數對於 IO 效能及穩定性等會有不小的影響。</p><ul><li>dirty_background_ratio: 當 dirty page 佔用到記憶體的多少百分比時，核心會開始觸發背景寫回</li><li>dirty_background_bytes: dirty_background_ratio 以 bytes 為計算方式的版本，兩者只能指定其中一個</li><li>dirty_ratio: 當 dirty page 佔用到記憶體的多少百分比時，寫入的 IO 會開始遭到阻擋</li><li>dirty_bytes: dirty_ratio 以 bytes 為計算方式的版本，兩者只能指定其中一個</li><li>dirty_writeback_centisecs: flusher 會週期性的被喚醒執行，此為喚醒間隔，單位為百分之一秒</li><li>dirty_expire_centisecs: dirty page 超過該時間後，flusher 被喚醒後就會將其寫回，單位為百分之一秒</li><li>swappiness: 當記憶體不足時，核心傾向選擇將資料搬移到 swap 還是放棄 page cache<ul><li>合法範圍是 0 ~ 100，預設值為 60</li><li>越高代表越傾向保留 page cache，也就是越容易進行 swap</li><li>越小則是越容易進行 swap，而越傾向放棄 page cache</li></ul></li></ul><p>　　Page cache 在一般讀寫情況下都可以運作良好，但有幾個情境會受到影響。首先是系統當掉或是異常斷電，由於 dirty page 還在記憶體中尚未寫入到磁碟的關係，當系統異常斷電時，資料就隨著電力中斷而揮發。另外一種情況是無法安排寫入順序，應用程式可能會有安排的寫入順序，但資料進入到 cache 後，核心會根據效能考量等因素重新安排寫入磁碟的順序，這在一般應用不會受到影響，但某些資料庫系統可能會為了避免資料有不一致的狀態，會期望資料在某些時間能按照某些順序寫入磁碟。這些情況就會需要使用 fsync() 等同步 IO 機制。</p><p>　</p><h2 id=fsyncfdatasync-及-sync-系統呼叫>fsync()、fdatasync() 及 sync() 系統呼叫</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#e5e5e5>#include</span> <span style=color:#e5e5e5>&lt;unistd.h&gt;</span><span style=color:#e5e5e5>
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5></span>
</span></span><span style=display:flex><span><span style=color:violet>int</span> <span style=color:#ff0>fsync</span>(<span style=color:violet>int</span> fd);
</span></span><span style=display:flex><span><span style=color:violet>int</span> <span style=color:#ff0>fdatasync</span>(<span style=color:violet>int</span> fd);
</span></span><span style=display:flex><span><span style=color:violet>void</span> <span style=color:#ff0>sync</span>();</span></span></code></pre></div><p>　　fsync() 會確保 fd 所映射的檔案所有 dirty 的資料及 metadata (中繼資料，如 indoe 包含的時間戳等屬性) 寫回到磁碟中。而 fdatasync() 則會寫回 dirty 的資料及必要的中繼資料，fdatasync() 不保證非必要的中繼資料會寫回到磁碟，因此速度可能會比較快。這兩個函式成功時會返回 0，失敗時返回 -1 並設定 errno。</p><p>　　儘管核心已經要求將資料寫回到磁碟中，且磁碟也回報資料已經寫回，但現今許多的硬碟也都含有自己的寫入快取，因此也不一定真正保證資料已經完全寫入到磁碟。另外這這兩個函式只能保證該檔案的內容已經與磁碟同步，但不包含所屬檔案的目錄，因此如果操作有涉及到目錄的話，還必須連同目錄本身的 fd 調用 fsync() 才能保證異動都寫回磁碟。</p><p>　　sync() 系統呼叫沒有參數也沒有回傳值，他會將所有的 cache 資料都寫回到磁碟。標準並沒有要求 sync() 一定要全部都寫回後才返回，但 Linux 會等到所有緩衝區都寫回才返回。一般不會建議使用 sync()，因為在忙碌的系統上，sync() 有可能會需要數分鐘以上的時間才能完成。</p><p>　</p><h2 id=o_synco_dsync-及-o_rsync>O_SYNC、O_DSYNC 及 O_RSYNC</h2><p>　　如果在 open() 時有帶 O_SYNC 旗標的話，則該 fd 所有的 write() 都會進行同步，等效於所有的 write() 返回前都再自動呼叫 fsync()。O_DSYNC 是 O_SYNC 的 fdatasync() 版本。 O_RSYNC 目前被定義成等價於 O_SYNC，他的規範要求是讀取時也必須進行同步，例如讀取時可能會更新資料的 access time，在 read() 返回前也必須同步到磁碟，不過如先前所述，他目前在 Linux 並無實作。</p><p>　</p><h2 id=buffered-io>Buffered IO</h2><p>　　標準IO函式庫 (stdio) 還實作了一系列 fopen、fread()及fwrite()等函式，與 read()、write() 等系統呼叫最主要的差異是，stdio 在 Userspace 實作了一層 buffer。實作 buffer 的主要原因是 read()、write() 系統呼叫在運作時會需要對齊 block size，對於小於一個 block size 的呼叫，核心仍然會以一個 block size 為單位進行處理，對於較小且未對齊的資料效能會有影響，也會增加不少系統呼叫的次數。</p><p>　　標準IO函式庫的緩衝型式可以在 fopen() 呼叫之後，進行其他操作之前，使用 setvbuf() 函式來進行設定，可以是以下三種的其中一種:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#e5e5e5>#include</span> <span style=color:#e5e5e5>&lt;stdio&gt;.h&gt;</span><span style=color:#e5e5e5>
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5></span>
</span></span><span style=display:flex><span><span style=color:violet>int</span> <span style=color:#ff0>setvbuf</span>(FILE *stream, <span style=color:violet>char</span> *buf, <span style=color:violet>int</span> mode, <span style=color:violet>size_t</span> size);</span></span></code></pre></div><ul><li>_IONBF: 無緩衝</li><li>_IOLBF: 以 line 為單位做緩衝，遇到 \n 字元就會提交給核心，可應用於終端機，如 stdout</li><li>_IOFBF: 以 buf 做為緩衝區進行緩衝，大小為 size。若 buf 為 NULL，則會根據 size 自動配置一個</li></ul><p>　　另外還有一個 setbuf() 函式，他等價於 setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZE)。</p><p>　　下圖很清楚地說明了 User space buffer 及 Kernel buffer cache (page cache) 之間的關係 (原始出處應該是 Linux Programming Interface 一書)</p><figure class=center><img src=/images/2019/01/two-flush.png alt></figure><p>　</p><h2 id=參考資料>參考資料</h2><p><a href=https://www.tenlong.com.tw/products/9789862769812>Robert Love. Linux System Programming</a></p><div class="share-icons d-flex justify-content-center d-print-none"><a href="https://twitter.com/intent/tweet?url=https%3a%2f%2fblog.jaycetyle.com%2f2019%2f01%2flinux-read-write%2f&text=Linux%20%e7%b3%bb%e7%b5%b1%e7%a8%8b%e5%bc%8f%e8%a8%ad%e8%a8%88%20-%20read%28%29%e3%80%81write%28%29%20%e8%88%87%20page%20cache&tw_p=tweetbutton" class=p-2 title="Share on Twitter" target=_blank rel=nofollow><div><span class=fa-stack><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-twitter fa-stack-1x fa-inverse"></i></span></div><div class="fa-inverse text-center"><small>Tweet</small></div></a><a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fblog.jaycetyle.com%2f2019%2f01%2flinux-read-write%2f&t=Linux%20%e7%b3%bb%e7%b5%b1%e7%a8%8b%e5%bc%8f%e8%a8%ad%e8%a8%88%20-%20read%28%29%e3%80%81write%28%29%20%e8%88%87%20page%20cache" class=p-2 title="Share on Facebook" target=_blank rel=nofollow><div><span class=fa-stack><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-facebook fa-stack-1x fa-inverse"></i></span></div><div class="fa-inverse text-center"><small>Share</small></div></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.jaycetyle.com%2f2019%2f01%2flinux-read-write%2f&title=Linux%20%e7%b3%bb%e7%b5%b1%e7%a8%8b%e5%bc%8f%e8%a8%ad%e8%a8%88%20-%20read%28%29%e3%80%81write%28%29%20%e8%88%87%20page%20cache&source=mattbutton.com" class=p-2 title="Share on LinkedIn" target=_blank rel=nofollow><div><span class=fa-stack><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></div><div class="fa-inverse text-center"><small>Share</small></div></a><a href=javascript:window.print() title="Print this article" class=p-2 target=_blank rel=nofollow><div><span class=fa-stack><i class="fas fa-circle fa-stack-2x"></i>
<i class="fa fa-print fa-stack-1x fa-inverse"></i></span></div><div class="fa-inverse text-center"><small>Print</small></div></a></div></div><h4>相關文章推薦</h4><ul><li><a href=/2018/12/linux-fd-open-close/>Linux 系統程式設計 - fd 及 open()、close() 系統呼叫</a></li><li><a href=/2018/10/vscode-gnu-global/>VS Code + GNU Global - 打造 Trace Linux Kernel 環境</a></li></ul><div id=giscus-comments><script src=https://giscus.app/client.js data-repo=jaycetyle/jaycetyle.github.io data-repo-id=MDEwOlJlcG9zaXRvcnkxMTYyNTQ2Mjk data-category=Comments data-category-id=DIC_kwDOBu3npc4CouiB data-mapping=pathname data-theme=preferred_color_scheme data-lang=zh-TW crossorigin=anonymous async></script></div></div><div class="sidebar d-print-none d-none d-xl-block"><h5 class="mt-4 post-title">Recent Posts</h5><ul class="mt-2 pl-4"><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com/2025/04/cloudflare-web-analytics/>Cloudflare Web Analytics：一個免費、無 Cookie 的網站分析工具</a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com/2025/04/gpt-dark-mode/>全部複製貼上！我用 Chatgpt 幫網站加了一個暗色模式</a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com/2021/10/linux-fio-tips/>Linux fio 測試參數的眉眉角角</a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com/2021/10/kprobe-userspace-tool/>Kprobe Userspace Tool 使用筆記</a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com/2019/12/linux-bug-on-case-study/>Linux Kernel BUG_ON 傾印訊息分析及案例分享</a></li></ul><h5 class="mt-4 text-capitalize post-title">Tags</h5><ul class="mt-2 pl-4"><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/c/c++/>C/C++
<span class="badge badge-pill badge-secondary">11</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/ubuntu-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/>Ubuntu 作業系統
<span class="badge badge-pill badge-secondary">7</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/linux-kernel/>Linux Kernel
<span class="badge badge-pill badge-secondary">6</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/%E7%B6%B2%E7%AB%99%E6%9E%B6%E8%A8%AD/>網站架設
<span class="badge badge-pill badge-secondary">5</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/>開發環境
<span class="badge badge-pill badge-secondary">5</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/>版本控制
<span class="badge badge-pill badge-secondary">4</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/%E9%96%92%E8%81%8A/>閒聊
<span class="badge badge-pill badge-secondary">4</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/%E6%A8%B9%E8%8E%93%E6%B4%BE/>樹莓派
<span class="badge badge-pill badge-secondary">3</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/ai/>AI
<span class="badge badge-pill badge-secondary">1</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/c%23/>C#
<span class="badge badge-pill badge-secondary">1</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/linux-system-performance/>Linux System Performance
<span class="badge badge-pill badge-secondary">1</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/nas-%E8%88%87%E8%B3%87%E6%96%99%E5%82%99%E4%BB%BD/>NAS 與資料備份
<span class="badge badge-pill badge-secondary">1</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/python/>Python
<span class="badge badge-pill badge-secondary">1</span></a></li><li class="mt-2 mb-2"><a href=https://blog.jaycetyle.com//tags/%E5%B7%A5%E5%85%B7%E8%BB%9F%E9%AB%94/>工具軟體
<span class="badge badge-pill badge-secondary">1</span></a></li></ul></div></div><footer class="mt-auto footer d-print-none"><div class=container-fluid><div class="d-flex col-xl-12 justify-content-center"><div>© 2019<a href=https://blog.jaycetyle.com/about/> Lin Chieh ( Jayce )</a>. Powered by <a href=https://gohugo.io/>Hugo</a> using <a href=https://www.mattbutton.com>Matt Button</a>'s <a href=https://github.com/mattbutton/silhouette-hugo>Silhouette Hugo</a> theme.</div></div></hr><div class="d-flex justify-content-center icons"><a class="py-2 px-2" href=https://www.linkedin.com/in/chieh-lin-569430a9/><i class="fab fa-linkedin"></i></a>
<a class="py-2 px-2" href=https://github.com/jaycetyle/><i class="fab fa-github"></i></a>
<a class="py-2 px-2" href=https://blog.jaycetyle.com/index.xml><i class="fas fa-rss"></i></a></div></div></footer><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js defer integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js defer integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js defer integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "4de65edc00b04409bbadda7f7dc762e6"}'></script></body></html>